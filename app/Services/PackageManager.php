<?php

namespace App\Services;

use App\Component\Base\PhpParser;
use App\Component\Base\Filesystem as Filesystem;
use App\Component\Package\Module as Module;

use App\Console\Commands\Support\PackageBuilder;

class PackageManager
{
    const SERVICE_PROVIDERS_DUMP_BASENAME = 'service-providers-%s.php';
    const ROUTES_MAP_DUMP_BASENAME = 'routes-map-%s.php';
    const MODULE_ROUTES_DUMP_BASENAME = 'routes-%s-%s.php';
    const METACLASSES_MAP_DUMP_BASENAME = 'metaclasses-%s.php';

    const CORE_MODULE_NAME = 'phpcrystal';

    const LOCAL_ENV = 'local';
    const PRODUCTION_ENV = 'prod';
    const PHPUNIT_ENV = 'phpunit';

    private $modules = [];

    /** @var array */
    private $metaClassesMap = [];

    /**
     * @return void
     */
    private function scanModules()
    {
        Filesystem\Finder::findByFilename(base_path() . '/modules', 'manifest.php', function($manifest) {
            $this->modules[] = new Module\Module(Module\Manifest::createFromFile($manifest));
        })
            ->setMaxDepth(1)
            ->run();
    }

    private function dumpMetaClassesMap($env) : void
    {
        $combinedMap = [];

        foreach ($this->getModules() as $module) {
            $combinedMap = array_merge($combinedMap, $module->getMetaClassesMap());
        }

        $filename = self::generateDumpFilename(self::METACLASSES_MAP_DUMP_BASENAME, $env);

        Filesystem\Aux::write($filename, serialize($combinedMap), 0666);
    }

    private function dumpControllersMap($env) : void
    {
        $combinedMap = [];

        foreach ($this->getModules() as $module) {
            $combinedMap = array_merge($combinedMap, $module->getControllersMap());
        }

        $filename = self::generateDumpFilename(self::CONTROLLERS_MAP_DUMP_BASENAME, $env);

        Filesystem\Aux::append($filename, serialize($combinedMap), 0666);
    }

    /**
     * @return void
     */
    private function dumpRoutingMap($env)
    {
        $filename = self::generateDumpFilename(self::ROUTES_MAP_DUMP_BASENAME, $env);
        Filesystem\Aux::phpAutogenerated($filename);

        $mapContent = '';

        foreach ($this->getModules(true) as $module) {
            /** @var Module\Manifest $manifest */
            $manifest = $module->getManifest();

            $subdomain = $manifest->getRouterSubDomain();
            $prefix = $manifest->getRouterUriPrefix();

            $middlewares = array_merge($manifest->getRouterMiddlewares(),
                ['module']);

            $record = sprintf('Route::middleware(%s)',
                PhpParser::toPhpArray($middlewares));

            if ($subdomain) {
                $record .= "->domain('$subdomain')";
            }

            if ($prefix) {
                $record .= "->prefix('$prefix')";
            }

            $record .= sprintf('->group(function() { require %s; })',
                sprintf('storage_path(\'framework/cache/%s\')',
                    sprintf(self::MODULE_ROUTES_DUMP_BASENAME, $module->getName(), $env)));

            $record .= ";\n";
            $mapContent .= $record;
        }

        Filesystem\Aux::append($filename, $mapContent, 0555);
    }

    public function __construct()
    {
        // Find all modules in ./modules dir
        $this->scanModules();

        // Add the core module
        $coreModule = new Module\Module(Module\Manifest::createFromFile(app_path('manifest.php')), self::CORE_MODULE_NAME);

        $this->addModule($coreModule);

        $this->loadMetaClassesMap();
    }

    /**
     *
    */
    public static function generateDumpFilename($tpl, ...$tplArgs): string
    {
        return storage_path('framework/cache/' . sprintf($tpl, ...$tplArgs));
    }

    /**
     *
     */
    public function loadMetaClassesMap() : self
    {
        $filename = self::generateDumpFilename(self::METACLASSES_MAP_DUMP_BASENAME, env('APP_ENV'));

        if (file_exists($filename)) {
            $this->metaClassesMap = unserialize(file_get_contents($filename));
        }

        return $this;
    }

    /**
     *
    */
    public function loadRoutingMap() : self
    {
        $filename = self::generateDumpFilename(self::ROUTES_MAP_DUMP_BASENAME, env('APP_ENV'));

        if (file_exists($filename)) {
            require $filename;
        }

        return $this;
    }

    /**
     * @return \App\Component\Package\Module\Module
     *
     * @throws \RuntimeException
    */
    public function getModuleByName($name)
    {
        foreach ($this->getModules() as $module) {
            if ($name == $module->getName()) {
                return $module;
            }
        }

        throw new \RuntimeException(sprintf('Failed to find package module %s', $name));
    }

    /**
     * @param $env
     */
    private function packageControllers($env) : void
    {
        foreach ($this->getModules(true) as $module) {
            $module->buildControllers($env);
        }

        $this->dumpRoutingMap($env);
    }

    /**
     * @param $env
     */
    private function packageServices($env) : void
    {
        $providersDump = self::generateDumpFilename(self::SERVICE_PROVIDERS_DUMP_BASENAME, $env);
        Filesystem\Aux::phpAutogenerated($providersDump);

        foreach ($this->getModules() as $module) {
            $module->buildServices($env);
        }

        Filesystem\Aux::append($providersDump, Module\Module::generateTaggedServices());
    }

    /**
     * @param $env
     */
    private function packageAll($env) : void
    {
        $this->packageControllers($env);
        $this->packageServices($env);
    }

    /**
     *
     */
    public function build($env = self::LOCAL_ENV, $target = null) : void
    {
        clearstatcache();

        switch ($target) {
            case PackageBuilder::TARGET_CONTROLLERS:
                $this->packageControllers($env);
                break;
            case PackageBuilder::TARGET_SERVICES:
                $this->packageServices($env);
                break;
            default:
                $this->packageAll($env);
        }

        $this->dumpMetaClassesMap($env);
    }

    /**
     * @return array
     */
    public function getModules($appOnly = false) : array
    {
        if ($appOnly) {
            $appModules = [];

            foreach ($this->modules as $module) {
                if ($module->getName() == self::CORE_MODULE_NAME) {
                    continue;
                }

                $appModules[] = $module;
            }

            return $appModules;
        } else {
            return $this->modules;
        }
    }

    /**
     * @return $this
    */
    public function addModule(Module\Module $newModule) : self
    {
        foreach ($this->modules as $module) {
            if ($module->getName() == $newModule->getName()) {
                throw new \RuntimeException(sprintf('A module name must be unique, failed to load "%s" module',
                    $newModule->getName()));
            }
        }

        $this->modules[] = $newModule;

        return $this;
    }

    /**
     * @return \App\Component\Package\Module\
     */
    public function getModuleByClassName($className)
    {
        foreach ($this->metaClassesMap as $key => $metaClass) {
            if ($key == $className) {
                return $this->getModuleByName($metaClass->getModuleName());
            }
        }

        throw new \RuntimeException();
    }

    public function getAnnotationInstance($targetClass, $targetMethod =  null, $annotClass)
    {
        /** @var \App\Component\Package\AbstractMetaClass $targetMetaClass */
        $targetMetaClass = null;

        foreach ($this->metaClassesMap as $className => $metaClass) {
            if ($targetClass == $className) {
                $targetMetaClass = $metaClass;
            }
        }

        if (is_null($targetMetaClass)) {
            throw new \RuntimeException(sprintf('Failed to retrieve routing action'));
        }

        return $targetMetaClass->getMergedAnnotations($annotClass, $targetMethod);
    }
}